Размышления о безопасности
Контрольная точка архитектуры RT-системы (rev. 2)
Статус

Документ фиксирует архитектурные инварианты и границы ответственности.
Это не финальная спецификация, а опорная модель для дальнейшей формализации.

1. Два несмешиваемых уровня безопасности
1.1 Catastrophic safety (аппаратный уровень)

Реализуется вне RT-библиотеки:

watchdog reset

active-low TRIP с аппаратным latch

внешний safety-MCU

отключение питания / выходов

Свойства:

монотонность (без возврата без reset)

минимальная латентность

нулевая доверенность к ПО

Инвариант:
RT-библиотека не реализует catastrophic safety и не зависит от него.

1.2 Managed degradation safety (RT-уровень)

Назначение:

управляемое ухудшение поведения до аппаратного TRIP

сохранение контролируемости системы

предотвращение катастрофы

Библиотека:

предоставляет механизм деградации,
но не гарантирует его достаточность.

2. Запрет lossy-данных в safety-контуре

Запрещено использовать для safety-решений:

event rings

log rings

любые очереди с возможной потерей

Причина:

нет гарантии доставки

нет гарантии наблюдаемости

поведение недоказуемо

Инвариант:
Safety-решения принимаются только по состояниям, никогда по событиям.

3. Единственный допустимый носитель safety-состояния
State-snapshot модель

Реализация:

DoubleBuffer<T>


Свойства:

lossless last-writer-wins

wait-free чтение

bounded запись

детерминированная наблюдаемость

Следствие:

Все safety-решения основаны только на snapshot-состояниях.

4. Архитектура safety-плоскости RT-уровня
4.1 Safety-задачи (уровень приложения)

работают в RT-домене

публикуют:

DoubleBuffer<SafetyState_i>


Особенности:

распределённые источники оценки риска

логика полностью принадлежит приложению

4.2 Глобальный Safety Administrator (RT, приложение)

Функции:

читает все SafetyState_i

агрегирует по прикладной логике

публикует:

TaskSafetyState[task]
SystemSafetyState (опционально)


Принцип:

Наблюдение распределено, решение централизовано.

4.3 Планировщик (уровень библиотеки)

Роль:

не принимает решений

механически применяет safety-состояния:

skip

throttle

stop

panic loop

Это исполнитель, а не аналитик.

5. Критические компоненты и наблюдаемость
5.1 Критические задачи

Задачи с признаком:

critical = true


обязаны:

регулярно обновлять состояние

оставаться наблюдаемыми в пределах заданного тайм-окна

5.2 Потеря наблюдаемости

Если:

критическая задача

или Safety Administrator

перестаёт обновлять состояние
(с учётом гистерезиса/таймаута),

то это трактуется как:

катастрофический отказ.

Следствие:

прекращение кормления watchdog

аппаратный TRIP / reset

Режим “тихого выживания” запрещён.

6. Граница ответственности библиотеки
6.1 Библиотека предоставляет

детерминированный RT-runtime

state-based publication механизм

execution metadata и scheduler-hooks

инфраструктуру наблюдаемости состояний

механизмы применения деградации

6.2 Библиотека не предоставляет

safety-логику

критерии деградации

гарантии достаточности защиты

catastrophic hardware safety

recovery-политику

Формула:

Library  = mechanism
Application = policy + safety case

7. Отношение деградации к аппаратной катастрофе

Иерархия:

Hardware catastrophic safety
        ↑
RT managed degradation
        ↑
Normal execution


Смысл:

деградация существует только до TRIP

после TRIP:

либо система остановлена аппаратно

либо RT-runtime утрачивает смысл

8. Живость safety-цепочки

Не принадлежит библиотеке.

Обеспечивается приложением:

внутренние watchdog-механизмы

внешний независимый watchdog MCU

аппаратные схемы отключения

Определяется классом критичности системы,
а не архитектурой runtime.

9. Финальные инварианты контрольной точки

Catastrophic safety вне библиотеки.

Lossy-данные запрещены в safety.

Единственный источник — state snapshots (DoubleBuffer).

Safety-логика принадлежит приложению.

Планировщик — только исполнитель.

Библиотека даёт механизм, не гарантию.

Деградация имеет смысл только до TRIP.

Safety Administrator — критический компонент.

Потеря наблюдаемости критического компонента = TRIP.

10. Область следующей формализации

Ещё не определены:

lattice переходов TaskSafetyState

формальный ABI TaskState

WCET-границы Safety Administrator

правила восстановления после деградации

взаимодействие с внешним safety MCU

Это следующий этап:
переход от архитектурного мышления → к доказуемой спецификации.