COncepts +
RT/non-RT tags + 
task template +++

Trivial payload +++

[16:08]
Активный профиль: **Программист**

Ниже — **чистое инженерное резюме спринта**
и **контекст-снимок для старта следующего чата**.

Без лишнего текста.

---

# 1. Результат спринта (фактически достигнуто)

## 1.1 Type-system слой сформирован

Введены базовые compile-time контракты:

* `Steppable` — требует
  `void step(uint32_t) noexcept`
* `RtSafe` — типовая маркировка
  RT-допустимости payload
* `RtPayload` — композиция
  `RtSafe ∧ Steppable`

Это даёт:

```
невозможность собрать RT-задачу
с синтаксически неверным payload
```

→ первый формальный RT-инвариант.

---

## 1.2 Чёткое разделение ответственности

Зафиксирована архитектурная модель:

```
Payload      — алгоритм и состояние
RtSafe       — свойство payload
ExecPolicy   — контекст исполнения
Scheduler    — механизм вызова
TaskWrapper  — execution boundary
```

Ключевое правило:

```
non-RT payload → запрещён в RT policy
RT payload     → допустим в обоих доменах
```

Проверка делается **в связке (Payload × ExecPolicy)**
на этапе регистрации.

Registry остаётся **домен-нейтральным**.

---

## 1.3 Слой TaskWrapper реализован

Свойства:

* compile-time проверка `Steppable`
* `noexcept` вызов
* отсутствие владения
* отсутствие аллокаций
* heartbeat через `atomic`
* единый wrapper для RT и non-RT

Это:

```
первый execution-уровень RT-ядра
```

---

## 1.4 Payload-слой валидирован

Созданы:

* `trivial_rt_task`
* `trivial_nonrt_task`

Подтверждено:

* корректная сборка
* корректное исполнение
* корректная RT-типизация

Demo-приложение работает.

---

# 2. Архитектурные выводы спринта

## 2.1 Где живёт RT-допустимость

Окончательно зафиксировано:

```
RtSafe — свойство payload,
а не policy, wrapper или scheduler.
```

Policy может **требовать**,
но не **создавать** RT-безопасность.

Это критическая граница модели.

---

## 2.2 Универсальность wrapper — подтверждена

Принято решение:

```
TaskWrapper не знает RT/non-RT.
```

Это обеспечивает:

* отсутствие дублирования типов
* чистый layering
* масштабируемость scheduler-архитектуры

---

## 2.3 Первая формальная RT-гарантия получена

Compile-time правило:

```
RT policy ⇒ RtSafe payload
```

Это:

```
первый реальный safety-барьер системы
```

---

# 3. Текущее состояние RT-ядра

Готовы слои:

```
model/        ✔ contracts
modules/demo/ ✔ payload
exec/tasks/   ✔ wrapper
```

Не реализованы:

```
exec/policy/      ← следующий шаг
registry binding
scheduler
RT loop
non-RT workers
```

---

# 4. Главный открытый вопрос перед следующим спринтом

Ключевая архитектурная развилка:

```
Где хранится ExecPolicy после регистрации задачи?
```

Варианты:

1. внутри TaskWrapper
2. отдельной записью registry
3. type-erased metadata рядом с vtable  ← наиболее вероятный путь

Это решение:

```
определит форму scheduler-ядра
```

---

# 5. Контекст для старта нового чата

## 5.1 Система

Проект:

```
Cncl-RT-WAL
```

Тип:

```
real-time execution framework + WAL logging
```

Статус:

```
type-system и execution boundary сформированы
scheduler ещё не начат
```

---

## 5.2 Инварианты, которые уже нельзя ломать

```
RtSafe принадлежит payload
TaskWrapper универсален
Registry доменно-нейтрален
RT-запрет проверяется через Policy × Payload
никаких runtime-проверок RT-допустимости
только compile-time
```

---

## 5.3 Следующая цель разработки

Начало следующего спринта:

```
ExecPolicy layer
↓
type-erased task record
↓
SystemRegistry finalize → rt/non-rt views
↓
первичный scheduler каркас
```

---

## 5.4 Формулировка задачи для следующего чата

Коротко:

> Спроектировать хранение ExecPolicy
> и структуру записи задачи в registry
> без нарушения RT-инвариантов и layering.

Это **естественное продолжение** текущего спринта.

---


